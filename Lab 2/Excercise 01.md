**Exercise 1**
---

In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).
```
boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
```
check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.

---

***My result***
---

- boot_alloc()
  - ![Uploading image.pngâ€¦]()
  - ```c
    static void * boot_alloc(uint32_t n)
    {
    	static char *nextfree;	// virtual address of next byte of free memory
    	char *result;
    
    	// Initialize nextfree if this is the first time.
    	// 'end' is a magic symbol automatically generated by the linker,
    	// which points to the end of the kernel's bss segment:
    	// the first virtual address that the linker did *not* assign
    	// to any kernel code or global variables.
    
    	if (!nextfree) {
    		extern char end[];
    		nextfree = ROUNDUP((char *) end, PGSIZE);
    	}
    
    	// Allocate a chunk large enough to hold 'n' bytes, then update
    	// nextfree.  Make sure nextfree is kept aligned
    	// to a multiple of PGSIZE.
    
    	// LAB 2: Your code here.
    	uint32_t req_npages = n / PGSIZE;
    	if(req_npages > npages)				//npages is the number of available memory page
    		panic("Not enough spaces");
    	result = nextfree;
    	nextfree += req_npages * PGSIZE;
    	return result;
      }
    ```

---
