**Exercise 1**
---

In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).
```
boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
```
check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.

---

***My result***
---

- boot_alloc()
  - ```c
    static void * boot_alloc(uint32_t n)
    {
    	static char *nextfree;	// virtual address of next byte of free memory
    	char *result;
    
    	// Initialize nextfree if this is the first time.
    	// 'end' is a magic symbol automatically generated by the linker,
    	// which points to the end of the kernel's bss segment:
    	// the first virtual address that the linker did *not* assign
    	// to any kernel code or global variables.
    	if (!nextfree) {
    		extern char end[];
    		nextfree = ROUNDUP((char *) end, PGSIZE);
    	}
    	// Allocate a chunk large enough to hold 'n' bytes, then update
    	// nextfree.  Make sure nextfree is kept aligned
    	// to a multiple of PGSIZE.
    	//
    	// LAB 2: Your code here.
    	uint32_t req_npages = n / PGSIZE;
    	if(req_npages > npages)				//npages is the number of available memory page
    		panic("Not enough spaces");
    	result = nextfree;
    	nextfree += req_npages * PGSIZE;
    	return result;
    }
    ```
- mem_init() (up to the call check_page_free_list(1))
  - ```c
      void mem_init(void)
      {
      	uint32_t cr0;
      	size_t n;
      
      	// Find out how much memory the machine has (npages & npages_basemem).
      	i386_detect_memory();
      
      	//Remove this line when you're ready to test this function.
      	//panic("mem_init: This function is not finished\n");
      
      	//////////////////////////////////////////////////////////////////////
      	// create initial page directory.
      	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
      	memset(kern_pgdir, 0, PGSIZE);
      
      	//////////////////////////////////////////////////////////////////////
      	// Recursively insert PD in itself as a page table, to form
      	// a virtual page table at virtual address UVPT.
      	// (For now, you don't have understand the greater purpose of the
      	// following line.)
      
      	// Permissions: kernel R, user R
      	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
      
      	//////////////////////////////////////////////////////////////////////
      	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
      	// The kernel uses this array to keep track of physical pages: for
      	// each physical page, there is a corresponding struct PageInfo in this
      	// array.  'npages' is the number of physical pages in memory.  Use memset
      	// to initialize all fields of each struct PageInfo to 0.
      	/*
      	pde_t *kern_pgdir;		// Kernel's initial page directory
      	struct PageInfo *pages;		// Physical page state array
      	static struct PageInfo *page_free_list;	// Free list of physical pages
      	*/
      	// Your code goes here:
      	pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo *) * npages);
      	memset(pages, 0, sizeof(struct PageInfo *) * npages);
      
      	//////////////////////////////////////////////////////////////////////
      	// Now that we've allocated the initial kernel data structures, we set
      	// up the list of free physical pages. Once we've done so, all further
      	// memory management will go through the page_* functions. In
      	// particular, we can now map memory using boot_map_region
      	// or page_insert
      
      	page_init();
      
      	check_page_free_list(1);
      	check_page_alloc();
   ```
- page_init()
  - ```c
    void page_init(void)
    {
    	// The example code here marks all physical pages as free.
    	// However this is not truly the case.  What memory is free?
    	//  1) Mark physical page 0 as in use.
    	//     This way we preserve the real-mode IDT and BIOS structures
    	//     in case we ever need them.  (Currently we don't, but...)
    	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
    	//     is free.
    	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
    	//     never be allocated.
    	//  4) Then extended memory [EXTPHYSMEM, ...).
    	//     Some of it is in use, some is free. Where is the kernel
    	//     in physical memory?  Which pages are already in use for
    	//     page tables and other data structures?
    	//
    	// Change the code to reflect this.
    	// NB: DO NOT actually touch the physical memory corresponding to
    	// free pages!
    	size_t i;
    	pages[0].pp_ref = 0;
    	pages[0].pp_link = NULL;
    	page_free_list = NULL;
    	for(i = 1; i < npages_basemem; i++)
    	{
    		pages[i].pp_ref = PDX(page2pa(&pages[i]));
    		pages[i].pp_link = page_free_list;
    		page_free_list = &pages[i];
    	}
    	i += 96;
    	for(i; page2kva(&pages[i]) < (void *)&pages[npages]; i++)
    	{
    		pages[i].pp_ref = 0;
    		pages[i].pp_link = NULL;
    	}
    	for(i; i < npages; i++)
    	{
    		pages[i].pp_ref = PDX(page2pa(&pages[i]));
    		pages[i].pp_link = page_free_list;
    		page_free_list = &pages[i];
    	}
    }
    ```
  - Something i have to explain here:
    - ![image](https://github.com/vilesport/General-Xv6/assets/89498002/6580ab9b-3067-4598-ba97-3c010636dc41)
    - This is exactly memory layout look like.
    - See that npages_base will end at low memory, next pages until extended memory called IOPHYSMEM, so that i know next 96 pages after npages_basemem would never alloc
    - Then in extended memory, there are some pages of memory use to storage our data structures (included kern_pgdir and pages) and i know it ended at &pages[npages]. Then i use page2kva, it will return the page virtual address so i can compare to know that if current page storage our data structures or not.

- page_alloc()
  - ```c
    struct PageInfo * page_alloc(int alloc_flags)
    {
    	// Fill this function in
    	size_t i;
    	if(!page_free_list)
    		return NULL;
    	struct PageInfo * tmp = page_free_list->pp_link;
    
    	page_free_list->pp_link = NULL;
    	page_free_list->pp_ref = 0;
    
    	if(alloc_flags & ALLOC_ZERO)
    		memset(page2kva(page_free_list), '\0', PGSIZE);
    
    	struct PageInfo * res = page_free_list;
    	page_free_list = tmp;
    	return res;
    }
    ```
- page_free()
  - ```c
    void page_free(struct PageInfo *pp)
    {
    	// Fill this function in
    	if(pp->pp_link != NULL || pp->pp_ref != 0)
    		panic("Double free detected");
    	pp->pp_ref = PDX(page2pa(pp));
    	pp->pp_link = page_free_list;
    	page_free_list = pp;
    	// Hint: You may want to panic if pp->pp_ref is nonzero or
    	// pp->pp_link is not NULL.
    }
    ```

---
